# Results

```{r prepresults}
cachefile <- ".cache/mvtraits_results.rds"
results_all <- readRDS(cachefile)

max_ss <- max(sample_size$sample_size)

multi_summary <- results_all %>%
  filter(model_type %in% c("uni", "multi")) %>%
  mutate(
    mu_mean = map(data, c("mu", "Mean")) %>%
      map(~as_tibble(as.list(.))),
    mu_lo = map(data, c("mu", "2.5%")) %>%
      map(~as_tibble(as.list(.))),
    mu_hi = map(data, c("mu", "97.5%")) %>%
      map(~as_tibble(as.list(.)))
      ) %>%
  select(model_type:pft, mu_mean:mu_hi) %>%
  unnest(.sep = ".") %>%
  gather("variable", "value", -(model_type:pft), na.rm = TRUE) %>%
  separate(variable, c("stat", "param"), sep = "\\.") %>%
  spread(stat, value) %>%
  mutate(
    pft = factor(pft, abbr2pft) %>% forcats::lvls_revalue(pft2abbr),
    param = factor(param, both_params)
  )

hier_prep <- results_all %>%
  filter(model_type == "hier") %>%
  select(model_type:pft_type, data) %>%
  mutate(
    mu_vals = map(data, "mu_group"),
    pft = map(mu_vals, names),
    mu_df = map2(pft, mu_vals, ~tibble(pft = ..1, dat = ..2))
  ) %>%
  select(-data, -mu_vals, -pft) %>%
  unnest()

hier_summary <- hier_prep %>%
  mutate(
    mu_mean = map(dat, c("Mean")) %>%
      map(~as_tibble(as.list(.))),
    mu_lo = map(dat, c("2.5%")) %>%
      map(~as_tibble(as.list(.))),
    mu_hi = map(dat, c("97.5%")) %>%
      map(~as_tibble(as.list(.)))
      ) %>%
  select(model_type:pft, mu_mean:mu_hi) %>%
  unnest(.sep = ".") %>%
  gather("variable", "value", -(model_type:pft), na.rm = TRUE) %>%
  separate(variable, c("stat", "param"), sep = "\\.") %>%
  spread(stat, value) %>%
  mutate(
    pft = if_else(is.na(pft), "global", pft),
    pft = factor(pft, abbr2pft) %>% forcats::lvls_revalue(pft2abbr),
    param = factor(param, both_params)
  )

# Absolute comparison of means
means_dat <- multi_summary %>%
  filter(pft != "GLOB", !is.na(pft)) %>%
  bind_rows(hier_summary) %>%
  left_join(sample_size) %>%
  mutate(
    model_type = factor(model_type, c("uni", "multi", "hier")) %>%
      forcats::lvls_revalue(c("univariate", "multivariate", "hierarchical")),
    mass_area = factor(mass_area, c("mass", "area")),
  ) %>%
  mutate_at(
    c("mu_mean", "mu_lo", "mu_hi"),
    ~10 ^ .
  ) %>%
  filter(
    !(param %in% c("leaf_lifespan", "SLA") & mass_area == "area")
  )
```

## Estimates of PFT-level means

```{r meanvaluetable, results = "asis"}
## Write summary table
table_cap_mass <- paste(
  "Mean and 95\\% confidence interval of trait estimates",
  "for mass-normalized traits from the hierarchical model."
)
table_cap_area <- gsub("mass", "area", table_cap_mass)

censor <- function(rxp, pft, pfts, param, value) {
  if_else(grepl(rxp, param) & pfts %in% pft, "---", value)
}

table_dat <- means_dat %>%
  filter(
    model_type == "hierarchical",
    !(param %in% c("SLA", "leaf_lifespan") & mass_area == "area")
  ) %>%
  mutate(
    mu_lo = if_else(param == "Rdmass", mu_lo * 1000, mu_lo),
    mu_mean = if_else(param == "Rdmass", mu_mean * 1000, mu_mean),
    mu_hi = if_else(param == "Rdmass", mu_hi * 1000, mu_hi),
    mu_lo = if_else(param == "Rdarea", mu_lo * 1000, mu_lo),
    mu_mean = if_else(param == "Rdarea", mu_mean * 1000, mu_mean),
    mu_hi = if_else(param == "Rdarea", mu_hi * 1000, mu_hi),
    lo_f = formatC(mu_lo, digits = 3),
    mid_f = formatC(mu_mean, digits = 3),
    hi_f = formatC(mu_hi, digits = 3),
    value = sprintf("%s (%s,%s)", mid_f, lo_f, hi_f),
    value = censor("Vcmax|Jmax", "C4G", pft, param, value),
    value = censor("Rdmass", "ShDBo", pft, param, value),
    value = censor("Jmax_mass", c("NlEBo", "NlD"), pft, param, value),
    value = censor("Jmax_area", c("NlD"), pft, param, value)
  ) %>%
  select(pft, param, value) %>%
  mutate(
    param = factor(param, both_params) %>% 
      forcats::lvls_revalue(param_markdown_nounit[both_params]),
  )%>%
  spread(param, value) %>%
  arrange(pft)

table_dat %>%
  select(-matches("area")) %>%
  kable(caption = table_cap_mass, format = "latex",
        escape = FALSE, booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("scale_down"))
table_dat %>%
  select(-matches("mass")) %>%
  kable(caption = table_cap_area, format = "latex",
        escape = FALSE, booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("scale_down"))
```

(ref:mccap) Mean and 95% confidence interval on best estimates of traits for each plant functional type from the univariate, multivariate, and hierarchical models.
For leaf lifespan and SLA, results were not significantly different between the mass- and area-based models, so only results from the mass-based model are shown.
For some PFT-trait combinations, where large error bars resulting from the relatively uninformative priors are substantially larger than the variability among means, the $y$ axes are constrained to facilitate comparison.

```{r meancompare, fig.width=7, fig.height=7, fig.cap='(ref:mccap)'}
pclip <- function(p, pname, value, lim, hi = TRUE) {
  f <- ifelse(hi, `>`, `<`)
  if_else(p == pname & f(value, lim), lim, value)
}

plot_dat <- means_dat %>%
  mutate(
    #too_few = sample_size < 2,
    #mu_hi = if_else(too_few, NA_real_, mu_hi),
    #mu_lo = if_else(too_few, NA_real_, mu_lo),
    #mu_mean = if_else(too_few, NA_real_, mu_mean),
    irrelevant = grepl("Vcmax|Jmax", param) & pft == "C4G",
    mu_hi = if_else(irrelevant, NA_real_, mu_hi),
    mu_lo = if_else(irrelevant, NA_real_, mu_lo),
    mu_mean = if_else(irrelevant, NA_real_, mu_mean),
    ## TODO: Fix these in the prior and re-run
    mu_hi = pclip(param, "Vcmax_mass", mu_hi, 1.5),
    mu_hi = pclip(param, "Vcmax_area", mu_hi, 100),
    mu_hi = pclip(param, "Jmax_mass", mu_hi, 1.8),
    mu_hi = pclip(param, "Jmax_area", mu_hi, 150),
    mu_mean = pclip(param, "Jmax_area", mu_mean, 150),
    mu_hi = pclip(param, "Rdmass", mu_hi, 0.03),
    mu_mean = pclip(param, "Rdmass", mu_mean, 0.03),
    mu_lo = pclip(param, "Rdmass", mu_lo, 0.03),
    mu_hi = pclip(param, "Rdarea", mu_hi, 0.0025),
    mu_mean = pclip(param, "Rdarea", mu_mean, 0.0025),
    mu_lo = pclip(param, "Rdarea", mu_lo, 0.0025),
    mu_hi = pclip(param, "Parea", mu_hi, 0.285),
    #mu_lo = pclip(param, "Jmax_area", mu_lo, 40, FALSE),
    param = forcats::lvls_revalue(param, param_fancy_chr[both_params])
  )

p_means <- ggplot(plot_dat) +
  aes(x = interaction(model_type, pft),
      y = mu_mean, ymin = mu_lo, ymax = mu_hi,
      color = pft, shape = model_type) +
  geom_pointrange(size = 0.3) +
  facet_wrap(~param, scales = "free", ncol = 2,
              labeller = label_parsed) +
  scale_y_continuous() +
  scale_color_manual(values = pft_colors) +
  guides(
    shape = guide_legend(title = "Model type"),
    color = guide_legend(title = "PFT")
  ) +
  ylab("Trait estimate mean and 95% CI") +
  xlab("Model type and PFT") +
  theme_bw() +
  theme(
    text = element_text(size = 12),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.grid = element_blank()
  )
p_means
```

In general, leaf trait estimates from the univariate, multivariate, and hierarchical models were similar (Fig. \@ref(fig:meancompare)).
Where we observed differences between modles, the largest were between the univariate and multivariate models, while the additional constraint from the hierarchical model tended to have a minimal effect on trait estimates.
Significant differences in trait estimates between univariate and multivariate models occurred even for traits with relatively large sample sizes, such as leaf nitrogen content.

Evergreen PFTs had by far the largest leaf lifespan, with the longest lifespan observed for temperate and boreal needleleaf evergreen species.
Meanwhile, all of deciduous species had lifespans shorter than 7 months.
Among deciduous species, lifespan was generally longer in warmer biomes than colder ones.

Across-PFT patterns in SLA and $N_{mass}$, $P_{mass}$, and $R_{d,mass}$ were similar.
Temperate broadleaved deciduous trees and shrubs generally had among the highest values of these traits, while temperate evergreen trees and shrubs had generally among the lowest.
However, none of these patterns were universal to all four traits.
For example, tropical evergreen trees had relatively high $N_{mass}$ and average SLA and $R_{d,mass}$, but among the lowest $P_{mass}$.
Similarly, temperate and boreal shrubs had higher $N_{mass}$ and $P_{mass}$ than any of the grasses, but comparable SLA.

Across-PFT patterns in $N_{area}$, $P_{area}$, and $R_{d,area}$ were different from their mass-normalized counterparts.
For example, tropical broadleaved evergreen and needleleaf evergreen trees had among the lowest $N_{mass}$ and $P_{mass}$ basis but among the highest $N_{area}$ and $P_{area}$, while the opposite was true of deciduous temperate trees and shrubs.
Species with N contents near the middle of the observed range did not shift as dramatically depending on type of normalization.

C3 grasses had both the highest $V_{c,max,mass}$ and $V_{c,max,area}$.
Compared to broadleaved trees, temperate needleleaved evergreen trees had lower $V_{c,max,mass}$ but higher $V_{c,max,area}$.
Among broadleaved trees, deciduous trees had higher $V_{c,max,mass}$ and slightly higher $V_{c,max,area}$ than evergreen trees.

C3 grasses also had the highest $J_{max,area}$, but temperate broadleaved deciduous trees had the highest $J_{max,mass}$.
All of the shrub PFTs had the lowest $J_{max,mass}$ but average or above-average $J_{max,area}$, while the opposite was true of broadleaved tropical PFTs.
Of the tree PFTs, needleleaved evergreen trees had among the highest $J_{max,area}$ but the lowest $J_{max,mass}$.

We observed clear differences in the relative uncertainties of mean estimates with respect to sample size.
All of the high-latitude PFTs consistently had among the largest error bars around their mean estimates relative to other PFTs, while the traits with the largest uncertainties were dark respiration, $V_{c,max}$, and $J_{max}$.
For some of these trait-PFT combinations, such as estimates $J_{max,mass}$ for shrub PFTs, the additional constraint from trait covariance substantially reduced error bars, making it possible to compare estimates against those of other PFTs.
Our analysis of the relationship between model type, sample size, and estimate relative uncertainty found that this covariance-based constraint from the multivariate model becomes increasingly important at smaller sample sizes (\@ref(fig:civssamplesize)).
However, this analysis revealed no consistent significant benefit from the hierarchical model for our specific analysis.

(ref:sscap) Relative uncertainty in PFT-level trait estimates as a function of sample size for each model type.
Lines represent linear models ($\log(y) = b_0 + b_1 \log(x)$) fit independently for each model type.

```{r "civssamplesize", fig.width=4.4, fig.height=3, fig.cap='(ref:sscap)'}
## Relative uncertainty
cv_dat <- means_dat %>%
  mutate(
    cv = abs((mu_hi - mu_lo) / mu_mean)
  ) %>%
  filter(sample_size > 1)

cv_mod <- cv_dat %>%
  group_by(model_type) %>%
  nest() %>%
  mutate(
    cvfit = map(data, ~lm(log10(cv) ~ log10(sample_size), data = .))
  )

cv_coef <- cv_mod %>%
  mutate(
    coef = map(cvfit, broom::tidy)
  ) %>%
  unnest(coef) %>%
  select(model_type, term, estimate) %>%
  spread(term, estimate) %>%
  "names<-"(c("model_type", "intercept", "slope")) %>%
  mutate(
    eqn = sprintf("'%s: '~log[10](y) == %0.2f - %0.2f~log[10](x)", model_type, intercept, abs(slope))
  )

cv_pred <- cv_mod %>%
  mutate(
    grid = map(data, modelr::data_grid, sample_size = seq(5, max_ss)),
    cvpred = map2(grid, cvfit, modelr::add_predictions)
  ) %>%
  unnest(cvpred) %>%
  mutate(cv = 10 ^ pred)
  
x_lims <- range(cv_pred$sample_size)
y_lims <- range(cv_pred$cv)

relative_ci <- ggplot(cv_dat) +
  aes(x = sample_size, y = cv, color = model_type) +
  geom_point(size = 0.5) +
  geom_line(data = cv_pred) +
  annotate("text", x = rep(2500, 3), y = c(1.4, 1.25, 1.1), 
           label = cv_coef$eqn, parse = TRUE, 
           size = 2, vjust = "right") +
  scale_x_continuous(trans = "log10") +
  coord_cartesian(xlim = x_lims, ylim = y_lims) +
  xlab("Sample size") +
  ylab("Relative width of 95% CI") +
  scale_color_brewer(type = "qual", palette = 2) +
  guides(color = guide_legend(title = "Model type")) +
  theme_bw() +
  theme(
    legend.position = c(0.85, 0.75),
    panel.grid = element_blank()
  )
relative_ci
```


## Trait correlation patterns among- and within-PFTs

(ref:stickcap) Pairwise trait mean and covariance estimates for all data pooled globally (black) and for each PFT (colored).
Correlations not significantly different from zero are indicated by x symbols at the mean estimate.
$x$ and $y$ axes vary on a log scale, reflecting the fact that the model was fit using the base 10 log of all traits.

```{r stickpairs, fig.width = 5, fig.height = 5, fig.cap = '(ref:stickcap)'}
suppressPackageStartupMessages({
  library(mvtraits)
})
results_sub <- results_all %>%
  filter((model_type == "multi" & pft == "global") |
         (model_type == "hier"))
dat_list <- results_sub$data
names(dat_list) <- with(results_sub, paste(model_type, mass_area, sep = "_"))

stickplot_pairs(
  #mu_global_lower = dat_list$hier_mass$mu_global,
  #Sigma_global_lower = dat_list$hier_mass$Sigma_global,
  mu_global_lower = dat_list$multi_mass$mu,
  Sigma_global_lower = dat_list$multi_mass$Sigma,
  mu_group_lower = dat_list$hier_mass$mu_group,
  Sigma_group_lower = dat_list$hier_mass$Sigma_group,
  vars_lower = mass_params,
  group_names = pft2abbr[-1],
  vars_label = param_labels,
  unlog_axes = TRUE,
  #mu_global_upper = dat_list$hier_area$mu_global,
  #Sigma_global_upper = dat_list$hier_area$Sigma_global,
  mu_global_upper = dat_list$multi_area$mu,
  Sigma_global_upper = dat_list$multi_area$Sigma,
  mu_group_upper = dat_list$hier_area$mu_group,
  Sigma_group_upper = dat_list$hier_area$Sigma_group,
  vars_upper = area_params,
  col_group = pft_colors,
  cex_g = 1.2,
  lwd_g = 1,
  lty_g = 1,
  lwd_s = 1.3,
  par_plot = list(oma = c(0, 5, 3, 5), cex = 0.4),
  par_legplot = list(mar = c(0, 0, 0, 0)),
  par_legend = list(ncol = 5, x = "center", cex = 0.6),
  reorder_legend = TRUE
)
mtext("Mass-normalized", side = 2, cex = 0.7, line = 3)
mtext("Area-normalized", side = 4, cex = 0.7, line = 1)
```

Where pairwise trait correlations were statistically significant, these correlations were generally consistent in direction both globally and within each PFT (Fig. \@ref(fig:stickpairs)).
In particular, mass- and area-normalized traits were all positively correlated with each other and, respectively, positively and negatively correlated with SLA, both globally and within each PFT.
On the other hand, correlations between leaf lifespan and area-normalized traits were more variable.
The correlation between $N_{area}$ and leaf lifespan was positive both globally and for evergreen shrubs, but was negative for broadleaved deciduous trees and not significant for any other PFTs.
Similarly, the correlation between $P_{area}$ and leaf lifespan was positive for temperate broadleaved evergreen trees and needleleaved evergreen trees but negative for evergreen shrubs.

A large number of pairwise trait correlations were not significant.
In some cases, this was driven by sample size (Fig. \@ref(fig:samplesize)).
For instance, needleleaved deciduous trees were often the only PFT for which a correlation was not statistically significant.
In other cases, though, PFTs with smaller sample sizes had significant pairwise correlations while PFTs with much larger sample sizes had none.
For example, tropical broadleaved evergreen trees were relatively well-sampled for all traits, but none of their traits were well correlated with leaf lifespan.
Meanwhile, temperate broadleaved evergreen trees had significant correlations between leaf lifespan and SLA, $P_{area}$, and $R_{d,area}$.
In general, we observed fewer significant trait correlations among area-normalized traits than mass-normalized traits. 

```{r boxprep}
outdir <- "../output"
hier_mass_file <- tail(dir(outdir, "hier.mass.clm45", full.names = TRUE), 1)
hier_area_file <- tail(dir(outdir, "hier.area.clm45", full.names = TRUE), 1)
multi_mass_file <- tail(dir(outdir, "multi.mass.clm45", full.names = TRUE), 1)
multi_area_file <- tail(dir(outdir, "multi.area.clm45", full.names = TRUE), 1)

hier_summary_mass <- readRDS(hier_mass_file)[["summary_table"]] %>%
  mutate(mass_area = "mass")
hier_summary_area <- readRDS(hier_area_file)[["summary_table"]] %>%
  mutate(mass_area = "area")
multi_summary_mass <- readRDS(multi_mass_file)[["summary_table"]] %>%
  mutate(mass_area = "mass")
multi_summary_area <- readRDS(multi_area_file)[["summary_table"]] %>%
  mutate(mass_area = "area")

proc <- function(dat, hier = TRUE) {
  if (hier) {
    dat <- filter(dat, group != "global")
  } else {
    dat <- mutate(dat, group = "global")
  }
  dat <- dat %>%
    filter(variable == "Corr") %>%
    separate(index, c("xvar", "yvar"), sep = "\\.\\.") %>%
    mutate(
      pft = factor(group, abbr2pft) %>% forcats::lvls_revalue(pft2abbr)
    ) %>%
    select(mass_area, pft, xvar, yvar, Mean, `2.5%`, `97.5%`)
}

hsm <- proc(hier_summary_mass)
hsa <- proc(hier_summary_area)
msm <- proc(multi_summary_mass, FALSE)
msa <- proc(multi_summary_area, FALSE)
hs <- bind_rows(hsm, hsa, msm, msa)
```

(ref:corrbarscap) Mean and 95% CI on estimates of pairwise correlation coefficients
for all data pooled globally (dark grey) and for each PFT (colored).

```{r corrbars, fig.width=7, fig.height=7, fig.cap='(ref:corrbarscap)'}
.zzz <- close.screen(all.screens = TRUE)
corr_bar <- function(dat, xvar, yvar, mass_area) {
  dp <- dat %>%
    filter(
      mass_area == !!mass_area,
      (xvar == !!xvar & yvar == !!yvar) | 
        (xvar == !!yvar & yvar == !!xvar),
    ) %>%
    arrange(pft) %>%
    mutate(color = c("grey25", pft_colors))
  x <- barplot(dp$Mean, col = dp$color, border = dp$color,
               ylim = c(-1, 1), axes = FALSE)
  arrows(x, dp[["2.5%"]], x, dp[["97.5%"]],
         length = 0.01, angle = 90, code = 3)
  box()
}

nv <- length(mass_params)
main_screens <- split.screen(rbind(c(0, 1, 0.2, 1), c(0, 1, 0, 0.2)))
par(mar = rep(0.1, 4), oma = c(0, 8, 1, 5), cex = 0.4)
screens <- split.screen(c(nv, nv), screen = main_screens[1])
for (i in seq_len(nv)) {
  for (j in seq_len(nv)) {
    k <- j + nv * (i - 1)
    screen(screens[k])
    if (i == j) {
      # Label
      plot(0:1, 0:1, type = "n", ann = FALSE, axes = FALSE)
      box()
      text(x = 0.5, y = 0.5, labels = param_labels[i], cex = 2)
    } else {
      if (j > i) {
        # Upper triangle
        mass_area <- "area"
        xvar <- area_params[j]
        yvar <- area_params[i]
      } else {
        # Lower triangle
        mass_area <- "mass"
        xvar <- mass_params[j]
        yvar <- mass_params[i]
      }
      corr_bar(hs, xvar, yvar, mass_area)
    }
    if (i == 2 && j == 1) {
      axis(side = 2)
    }
    if (i == 1 && j == nv) {
      axis(side = 4)
    }
  }
}
## Draw legend
screen(main_screens[2])
par(mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0))
plot(0, 0, type = "n", axes = FALSE, ann = FALSE)
legend("center", legend = levels(hs$pft), fill = c("grey25", pft_colors), 
       ncol = 5, bty = "n")
close.screen(all.screens = TRUE)
mtext("Mass-normalized", side = 2, cex = 0.7, line = 1)
mtext("Mean and 95% CI of pairwise correlation", side = 2, cex = 1, line = 2)
mtext("Area-normalized", side = 4, cex = 0.7, line = 0)
```

The strength of pairwise trait correlations varied substantially depending on scale, PFT, and trait (Fig. \@ref(fig:corrbars)).
The two pairwise trait correlations that exhibited the most consistent strength globally and within each PFT were the correlation between SLA and $N_{area}$, and between $N_{mass}$ and $P_{mass}$.
Correlation strength was often related to sample size, with well-sampled PFTs exhibiting stronger correlations and undersampled PFTs exhibiting weaker correlations.
